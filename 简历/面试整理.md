### 换工作心得总结

换工作动机：薪资满足 + 精神满足 + 能力发展通道 ==> 物质要求【时薪？工作所得 + 工作付出？】 + 合适的事【好业务？】 + 合适的人【好老板？好同事？好制度】

面试岗位特点：填坑 or 新业务工作

选择哪种工作：喜欢的【增加动机？】 or 擅长的【学习提高？】

面试紧张怎么办? ==> 调整期待【确定非它不可？】；充分准备【自我介绍，项目讲解，技术知识，算法题目】



#### 简历和面试

STAR法则：情境(situation) - 任务（task）- 行动(action - 结果(result)

简历：基本信息 + 工作履历 + 项目经验 + 专业技能 + 个人评价 【浓缩到2页，项目使用STAR法则】

面试开场白：您好，我是张小侠。2015年毕业于浙江农林大学，信息与计算科学专业。我的经历大概分为2个阶段：第一段在一家小的公司做教育业务开发，这个阶段主要是积累技术能力的过程，负责前后端功能代码实现和阿里云服务器运维等工作；干了一年多后，感觉技术和业务没有成功成长空间。于是后来就去大厂。后来就去了格家网络干了3个年电商相关的业务，前面1年半做的促销中台的业务，主要负责促销优惠模型设计和优惠券和捕手币功能模块， 实现；之后的1年半主要做交易功能模块，主要负责购物车，交易履约，交易退款和交易结算的相关模块。设计交易模型【讲故事的环节，说明职业规划，说明工作内容，工作结果】

项目面试环节：目标【解决什么问题】 ==> 技术方案【功能模块，技术模块，数据流向】 ==> 项目产出【代码和文档，业务项目指标，可视化】。项目中遇到的挑战点：遗留业务相关技术离职，文档不完善；整理需求点，边看代码边整理文档和单测。快速进行需求开发。协调优惠券服务化改造，成本没法控制管理等...

技术面试环节：技术产生原因 ==> 技术原理【最佳实践 】 ==> 技术局限性 【最好结合自己项目使用】

认识自我优缺点：优点 ==> 有责任心交代给自己的事情能够尽职尽责的完成；热爱技术，有空就研究技术代码，比如看看dubbo和netty源码等；缺点：爱较真，讨论问题喜欢争论输赢，有的事情可能并不是非黑即白。

询问面试官环节：1). 公司使用的技术栈有哪些   2). 团队有哪些业务，目前面试的岗位需要哪些能力。

和Hr谈工资环节：面试前别写期待工资，统一写成面议。根据自己的面试情况和HR进行协商沟通。





####技术面试题

##### Java基础

* Hashmap原理
* 
* 面向对象的3大特性：封装，继承和多态



##### Java多线程

* 线程，进程，协程的区别：进程是操作系统分配资源的最小单位，进程和进程是互相独立的。线程是进程划分成的更⼩的运⾏单位,⼀个进程在其执⾏的过程中可以产⽣多个线程，可能共享进程中的内存，。

* java锁机制：乐观锁 + 悲观锁 + [非]公平锁 + [非]可重入锁【synchronized，ReentrantLock】

* 死锁条件和解决方案：互斥条件 + 请求和保持条件【一次持有多个锁】 + 不可剥夺【超时释放】 + 循环等待【申请资源的顺序】

* AQS实现原理：state + 等待队列 + 多个条件队列。

* volatile实现原理：在指令序列中添加**内存屏障**来禁止指令重排序的【解决可见性和有序性问题】。程序执行是会把主内存中的数据加载到cpu L1,L2缓存中，多线程修改变量，导致主内存和高速缓存数据不一致。内存屏障，保证在读变量从主内存重新加载数据，在写数据时候把高速缓存中的数据写入主内存。

* 线程池原理：先创建核心线程数来处理任务，到达核心线程数后则将任务加入到阻塞队列，如果阻塞队列也满了则创建最大线程数进行处理任务，达到最大线程数并且任务也满了则触发拒接策略。

* 常用并发包：原子类【AtomicXXX】, 并发容器【CopyOnWriteArrayList, ConcurentHashMap, ConcurrentLinkedQueue】，阻塞队列【BlockingQueue】,

  协同工具类【信号量，闭锁，循环屏障】





##### JVM虚拟机

* 类加载过程：类加载 ==> 验证【验证类的合法性】 ==> 准备【设置常量】 ==> 链接【符号引用转为直接应用】==> 类初始化

* 双亲委派机制：BoostrapClassLoad, ExtClassLoad, AppClassLoad ==> 先委派给父类加载器，父类不能处理在自己处理。

* 垃圾回收算法：复制算法 + 标记清除 + 标记整理

* CMS和G1垃圾回收过程：

  CMS：初始标记【GCRoot】==> 并发标记 ==> 预清理 ==> 重新标记 ==> 并发清理 

  G1：初始标记 ==> 并发标记 ==> 最终标记 ==>清理垃圾



##### SpringBoot

* 作用：自动配置原理，减少复杂的配置，整合常用的组件。

* springboot集成包冲突怎么解决：版本总裁

  



##### Zookeeper

* zab协议：领导者选举 ==> 

* zk选举过程：连接领导者超时【looking状态】 ==> 投票给自己，广播给别人 ==> 接收到投票者信息后，进行领导者pk ==> 
* 脑裂问题：网络分区，导致多个主服务器。==> zk领导者选取和写入过程都是采用过半机制，解决zk脑裂问题。



##### MySQL/分库分表

* MySQL实现原理：WAL, redo, undo
* mysql的锁类型：表锁 + metadata lock + 共享锁 + 排他锁 + 间隙锁 + next-key lock
* online ddl实现：新建表结构文件 + 复制原来数据 + 新增事务放到row log中 + 复制完成应用row log【会有短暂锁表】
* 隔离级别：读脏 + 读已提交 + 可重复读 + 串行化
* MVCC实现原理：事务版本号 + undo日志
* DDL 小表比较慢的原因：表的事务操作需要获取metadata lock，执行ddl需要获取metadata 写锁，需要等待。
* 主从复制：binlog同步实现，canal
* 分布式事务解决 - 二阶段提交，TCC ，柔性事务【动态生成逆向SQL，无法实现隔离性】，消息队列实现最终一致性
* 分布式ID生成算法：UUID，号段模式，雪花算法【几种开源实现】





##### Redis和缓存

* 数据结构：字符串，集合，列表，排序列表，hash，bitmap, Hyploglog, geo
* 持久化方式：RDB，AOF
* 高可用方案：主从复制，哨兵机制, codis和cluster对比。
* 缓存雪崩，缓存穿透，缓存击穿
* 缓存一致性问题：cache aside, 
* 缓存淘汰策略：LRU,LFU, ROMDOM,  no, volitile-ttl
* 缓存删除策略：定期删除和延迟删除。
* 分布式锁和RedLock：分布式锁的实现



##### 消息队列

* 消息队列作用：异步解耦，流量削峰
* 消息的种类：普通消息 + 顺序消息 + 延时消息【自研】 + 事务消息
* 消息重复消费问题：至少一次投递，消费消息端需要保证接口幂等。
* 顺序消息实现：按照key进行分区，相同key的消息会在同一分区或者队列
* Rocket事务消息实现逻辑：RocketMQ采用了2PC来实现了提交事务消息，先发送事务消息【precommit】,然后执行本地事务【回调Producer的executeLocalTransaction方法】 ==> 业务提交后向Broker反馈Commit 或者Rollback【执行失败时】 ==> 超时会重试调用本地事务





##### 分布式服务

* 分布式和集群区别：应用服务化拆分和集群部署，数据库分库分表-主从，缓存的分片和主从，消息队列的分片和副本。
* 服务改造好处：系统资源扩展性问题【连接池】， 研发效率低下【沟通成本】，部署成本高【编译时间长】
* APM 追踪原理：traceID + spanID【Pinpoint】
* 限流算法【滑动窗口，令牌桶算法，漏桶算法】
* 限流，熔断、降级区别 ==> 熔断是其他系统的保护  ，降级是保护自己 ==>限流也是一种部分流量降级
* 降级，限流设计：【配置中心 -- 配置开关，限流规则数据，AOP 代理】
* 压测：设计场景  + 数据准备【根据真实请求模拟数据】 + 性能监控
* 领域驱动设计：共同语言 + 领域边界 + 实体 +  + 聚合 





##### Dubbo框架

* dubbo原理：服务注册和发现 ，集群容错，路由策略，负载均衡，filter链，SPI机制
* 负载均衡：客户端负载均衡和服务端负载均衡，算法：轮询，随机，权重轮询，最小活跃连接
* dubbo延迟暴露的目的：等待其他资源初始化完成。
* 设计RPC框架：服务注册和发现 ， 数据通讯【netty】 ， 数据格式【序列化编码- JDK, Json, Protobuf, Kryo】



##### netty框架

* Netty使用场景：网络传输，网络编程【rpc框架，http，websocket等】
* Netty线程模型：多reactor多线程，BossGroup对应的线程池处理accept io事件，WorkGroup对应的线程池处理 read, write对应的io事件。我们也可以使用独立的线程池处理业务逻辑。添加handler的时候指定业务线程池。
* Netty半包和粘包解决方案：tcp是面向流传输的。解决方式：固定长度，分隔符，固定长度字段存内容长度信息
* Netty零拷贝方案：CompositeByteBuf 类, 可以将多个 ByteBuf 合并为⼀个逻辑上的 ByteBuf , 避免了各个 ByteBuf 之间的拷⻉；通过 FileRegion 包装的 FileChannel.tranferTo 实现⽂件传输。

* 多路复用selector和 epoll区别：



##### 系统设计问题

* 秒杀系统设计：

* 短链接设计：hash算法 ==> murmurhash； hash冲突 ==> 给原链接地址加上一段特殊后缀。

* 限流，降级服务设计：功能设计和非功能设计。效果：定义注解【指定限流规则和降级规则数据】，使用AOP动态读取配置中心数据【限流规则】，

  

  

##### 排查问题和解决问题

* 代码异常：打印异常日志 ==> 通过入参分析代码异常。如果没有打印日志，我们需要选择某台机器使用Archas工具，通过参数分析问题
* 代码逻辑漏洞：代码数据由于考虑不周全，导致数据错乱。如果是刚发布，应该及时回滚。【分析代码业务逻辑，找出漏洞】
* 内存溢出问题：导出堆转储，使用MAT工具通过支配树，分析出内存泄露的地方。
* 性能问题：收集性能指标，报警反应过慢的请求。分析代码IO,使用SQL执行计划找出问题原因。【 批量处理，异步处理】
* 高并发问题处理：压测发现性能瓶颈【cpu, 数据库, 网络】，CPU使用率占用很大 ==> 我们就要增加应用服务器；数据库io性能 ==>对于查询我们需要增加缓存；对于写入问题，我们可以考虑分库分表或者使用消息队列;  网络流量太大 ==>可以使用静态化页面并搭配CDN，动态请求进行限流。

技术难点：海量业务数据存储和查询【分库分表 + 分布式事务处理】，高并发场景【缓存 + 消息队列 + 限流降级】，

复杂业务难点：需要把问题拆解【1个1个解决】；针对对于复杂业务，如果现有设计很难支持，只能找产品进行商量出一个折中方案。后期在进行重构。



